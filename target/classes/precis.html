<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Конспект</title>
</head>
<style>
    body {
        max-width: 70%;
        min-height: 400vh;
        margin-left: 10%;
        text-align: justify;
        font-family: Arial, sans-serif;
    }

    article {
        /*background: wheat;*/
        border-left: solid 5px #24b8ff;
        padding-left: 5%;
    }

    code, pre {
        /*font-size: 15px;*/
        font-weight: bold;
        background: rgba(245, 222, 179, 0.38);
    }

    li {
        margin-top: 1%;
        margin-bottom: 1%;
    }
</style>
<body>
<article>
    <h1>Maven. 9. Dependency scope</h1>
    <p>Кроме таких атрибутов как</p>
    <pre>
        &lt;groupId&gt;&lt;/groupId&gt;
        &lt;artifactId&gt;&lt;/artifactId&gt;
        &lt;version&gt;&lt;/version&gt;
    </pre>
    <p>
        Существует ещё атрибут <code>&lt;scope&gt;&lt;/scope&gt;</code>. Из есть пять разных вариантов:
    </p>
    <ul>
        <li>
            <code>&lt;scope&gt;compile&lt;/scope&gt;</code> - идёт по умолчанию в наши зависимости, даже если не
            указываем явно. Он говорит о том, что данная зависимость нужна для компиляции проекта. Т.е. без этой
            зависимости никак не сможем скомпилировать проект. Другими словами говоря, если соберём приложение в .jar
            файл, то этот файл будет полностью зависеть от зависимости другой, которая помечена как <b>compile</b>.
            Без неё он работать не будет.
        </li>
        <li>
            <code>&lt;scope&gt;provided&lt;/scope&gt;</code> (jakarta.servlet-api следует использовать не <b>compile</b>,
            а <b>provided</b>) - это означает, что эта зависимость будет предоставлена кем-то другим. В данном случае
            эта зависимость лежит в директории lib нашего Tomcat, а т.к. мы будем использовать веб-приложение, потому
            что
            эта зависимость нужна только для веб-приложений, то, следовательно, она будет в Tomcat'e и не нужно будет
            добавлять в CLASSPATH проекта. Поэтому это <b>provided</b>. Естественно, она добавляется для того чтобы
            могли
            обращаться к нашим классам из FirstServlet. В противном случае без <b>provided</b> зависимости просто не
            будет виден HttpServlet.
        </li>
        <li>
            <code>&lt;scope&gt;runtime&lt;/scope&gt;</code> прекрасный пример - драйвер в JDBC. (Подключим драйвер для
            postgres в commit maven 9). Т.е., во время компиляции нам не нужен этот драйвер (зависимость) вообще, только
            во время выполнения (когда получили соединения). <b>Проще говоря</b>, используем когда во время компиляции
            не надо, а во время runtime нужно.
        </li>
        <li>
            <code>&lt;scope&gt;system&lt;/scope&gt;</code> - <b>не следует никогда использовать</b> - означает, что
            указываем зависимость, который лежит у нас на компьютере. Т.е., по сути указываем путь к .jar, который лежит
            на компьютере (путь указывается тэгом <code>&lt;systemPath&gt;</code>). Следовательно, её не рекомендуется
            использовать вообще.
        </li>
        <li>
            <code>&lt;scope&gt;test&lt;/scope&gt;</code> - этот скоуп говорит о том, что эта зависимость нужна только
            во время выполнения наших тестов. В нашу результирующую .jar она не должна попасть так же как и
            <b>provided</b>. Только отличие в том, что <b>provided</b> нужна для выполнения и жизнедеятельности проекта,
            но будет предоставлена каким-то другим приложением. В случае же с <b>test</b> - она нам в принципе не нужна.
            Только тогда, когда выполним тесты и проверим, что приложение работает успешно.
        </li>
    </ul>
    <p>
        Чтобы посмотреть все зависимости, которые наследуются от других pom или модулей, если специальный плагин. Для
        этого в терминале обращаемся к плагину. Посмотрим какие есть goal у этого плагина:
        <code>mvn dependency:help</code>. У него много goal, но нас будут интересовать два из них:
    </p>
    <ul>
        <li>
            <code>dependency:analyze</code> - анализирует зависимости
        </li>
        <li>
            <code>dependency:tree</code> - билдит всю иерархию зависимостей вместе с зависимостью нашей зависимости
            и т.д. Называют ещё транзитивной зависимостью.
        </li>
    </ul>
    <p>
        Поэтому можем набрать <code>mvn dependency:analyze</code> и увидим статистику по зависимостям и принимать решение:
        что можно убрать, что оставить.
    </p>
</article>
<article>
    <h1>Maven. 8. Dependency management</h1>
    <p>
        Познакомимся с одним из основных тегов - <code>&lt;dependencies&gt;&lt;/dependencies&gt;</code>. Этот тег
        используется нами, а точнее maven проектами в том случае, когда нам необходимо привнести новую зависимость в
        проект. Т.е. по другому говоря, .jar файлы.
    </p>
    <p>
        В тэге <code>&lt;dependencies&gt;&lt;/dependencies&gt;</code> можем указывать только тег <code>&lt;dependency&gt;
        &lt;/dependency&gt;</code>. Таким образом можем подключать множество зависимостей и они будут в CLASSPATH нашего
        проекта. Для подключения зависимостей нужно подключать уникальный идентификатор, который состоит из трёх
        основных
        элементов:
    </p>
    <pre>
        &lt;groupId&gt;&lt;/groupId&gt;
        &lt;artifactId&gt;&lt;/artifactId&gt;
        &lt;version&gt;&lt;/version&gt;
    </pre>
    <p>
        Например, если хотим подключить зависимости сервлетов, то пишем:
    </p>
    <pre>
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;jakarta.servlet&lt;/groupId&gt;
                &lt;artifactId&gt;jakarta.servlet-api&lt;/artifactId&gt;
                &lt;version&gt;5.0.0&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    </pre>
    <p>
        Но когда мы их подключили, перейдя в класс и захотим написать сервлет, то в CLASSPATH не будет видна
        зависимость.
        Для этого мы должны "подтянуть" эту зависимость. <i>Подтянуть</i> - означает скачать зависимость в директорию
        локального репозитория под названием <b>.m2</b>, а именно <b>.m2/repository</b>. Этот репозиторий хранится
        локально и он является общим для всего локального компьютера и будет видна во всех проектах.
    </p>
    <p>
        Поэтому, переходим в эту директорию. Это дефолтная репозитория локального репозитория. В ней есть директория
        <b>/repository</b>. Именно <b>.m2/repository</b> используется maven'ом для скачивания сторонних зависимостей
        из удалённого репозитория. Перейдя в этот репозиторий можно посмотреть все зависимости, которые уже скачаны.
    </p>
    <p>
        Что у нас получается:
    </p>
    <img src="mvn-8-1.png" width="60%">
    <p>
        У нас есть проекты (first-maven в данном случае) и все они ищут зависимости локально на машине в директории
        пользователя <b>~/.m2/repository</b>. Если в этой директории не нашлось зависимости, то maven идёт в удаленный
        репозиторий, который прописан в <i>super pom</i>: <a href="https://repo.maven.apache.org/maven2">
        https://repo.maven.apache.org/maven2</a>. И оттуда, если нашлись зависимости, то скачиваются в локальный
        репозиторий и можем использовать в проекте. В следующий раз уже не пойдёт в удалённый репозиторий, если уже
        будет
        выкачано локально.
    </p>
    <p>
        В случае с нашим примером с jakarta: в .m2/repository должна лежать директория <b>jakarta</b>, в которой лежит
        директория <b>servlet</b>. Если туда зайдём, то увидим <b>jakarta.servlet-api</b>, а внутри неё будет директория
        <b>5.0.0</b>, потому-что версий может быть множество. И уже внутри этой директории будет лежать зависимость.
    </p>
    <img src="mvn-8-2.png" width="70%">
    <p>
        Перейдя в зависимость можно увидеть <b>-sources.jar</b> (отдельно jar с исходными кодами, по умолчанию maven
        всегда их подхватывает), дальше видим саму .jar с зависимостями скомпилированными и ещё .pom. Ещё есть .sha1, но
        оно сейчас не нужно, потому что используется для взаимодействия с удалёнными репозиториями. Теперь можем
        споконо использовать <b>.jar</b> в нашем проекте. Естественно, .m2/repository можно переписать, но она уже
        находится не в super pom, в настройках нашего maven: <b>${maven}/conf/settings.xml</b>. Именно в этом
        <b>settings.xml</b> можем поправить дефолтные репозитории, если захотим. <b>Но лучше этого не делать</b>.
    </p>
    <p>
        Мы увидили её в локальном репозитории, но почему-то у нас всё ещё сервлет не видит класс HttpServlet. Все потому
        что должны ещё заимпортить .jar в наш проект из нашего локального репозитория.
    </p>
    <img src="mvn-8-3.png" width="25%">
    <p>
        Более того, теперь мы видим все зависимости, которые нам подключил maven из локального репозитория. Таким
        образом, мы очень легко и просто можем подключать зависимости в наш проект.
    </p>
    <img src="mvn-8-4.png" width="25%">
</article>
<article>
    <h1>Maven. 7. Super POM - битый</h1>
    <p>
        <b>Super POM</b> - это по сути суперкласс, от которого наследуются другие классы. Т.е., super pom содержит XML
        атрибуты, которые билдятся по умолчанию даже если не указываем их в своем собственном pom. Через команду
        <code>mvn help:effective-pom</code>.
    </p>
    <p>
        Мы можем задавать только конкретные теги и атрибуты. Не можем придумать какие-то свои.
    </p>
</article>
</body>
</html>