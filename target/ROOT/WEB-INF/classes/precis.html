<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Конспект</title>
</head>
<style>
    body {
        max-width: 70%;
        min-height: 400vh;
        margin-left: 10%;
        text-align: justify;
        font-family: Arial, sans-serif;
    }

    article {
        /*background: wheat;*/
        border-left: solid 5px #24b8ff;
        padding-left: 5%;
        margin-top: 5%;
        margin-bottom: 5%;
    }

    code, pre {
        /*font-size: 15px;*/
        font-weight: bold;
        background: rgba(245, 222, 179, 0.38);
    }

    li {
        margin-top: 1%;
        margin-bottom: 1%;
    }
</style>
<body>
<article>
    <h1>Maven. 15. Packaging type war</h1>
    <p>
        Разберёмся с packaging type <b>war</b>. Чтобы создать java web-приложение есть два варианта: создать сразу
        веб приложение или создать из нашего обычного приложения (как сейчас), т.е. трансформировать его. Начнём с
        первого варианта.
    </p>
    <h2>Создадим сразу веб приложение через file->new project->maven</h2>
    <p><b>Важно:</b> такой первый вариант лучше не делать. Поэтому примера не будет.</p>
    <img src="mvn-15-1.png" width="40%">
    <h2>Создадим веб приложение из уже существующего</h2>
    <p>
        Для того создать веб приложение из уже существующего заходим в настройки приложения, а именно Modules и создаём
        новый модуль web:
    </p>
    <img src="mvn-15-2.png" width="60%">
    <p>
        Видим соответсвующую директорию рядом с директорией src:
    </p>
    <img src="mvn-15-3.png" width="20%">
    <p>
        Теперь, чтобы проект соблюдал Apache Maven структуру - переносим директорию web в директорию main. Далее,
        директория web в maven должна называться директорией webapp, поэтому переименовываем её.
    </p>
    <img src="mvn-15-4.png" width="20%">
    <p>
        Далее, в POM устанавливаем war для packaging type:
    </p>
    <pre>&lt;packaging>war&lt;/packaging></pre>
    <p>
        Поправляем директорию для веб-ресурсов:
    </p>
    <img src="mvn-15-5.png" width="60%">
    <p>
        И создадим артифкаты:
    </p>
    <img src="mvn-15-6.png" width="60%">
    <p>
        Теперь попробуем собрать через <code>mvn package</code>. Получим готовую директорию target:
    </p>
    <img src="mvn-15-7.png" width="20%">
    <p>
        <b>Следует помнить</b>, что зависимости не подтягиваются!
    </p>
    <p>
        Так же можем поменять название, чтобы название при упаковке было другое. Для этого воспользуемся специальным
        тегом <code>&lt;finalName>&lt;/finalName></code>, который должен быть в разделе build. Дадим название ROOT
        потому что именно это название характерно для веб-приложений у которых пустой context-path:
    </p>
    <pre>
        &lt;build>
            &lt;!-- Результат упаковки будет называться как ROOT. См. Maven 15 -->
            &lt;finalName>ROOT&lt;/finalName>
        &lt;/build>
    </pre>
    <p>
        Теперь, после упаковки результат target будет такой:
    </p>
    <img src="mvn-15-8.png" alt="">

</article>
<article>
    <h1>Maven. 14. Default Lifecycle. Package phase</h1>
    <img src="mvn-11-1.png" width="70%">
    <p>
        Между test и package есть <b>prepare-package</b>. Она никак не связана с goal'ами и служит для того, чтобы мы
        могли как-то привязать свои плагины и goal'ы к этой фазе или что-то изменить для фазы package. В самой фазе
        package происходит упаковка проекта в архив. Обычно это .jar архив, но может быть и .war и много другие.
    </p>
    <p>
        Вызовем <code>mvn package</code> и получим следующую информацию:
    </p>
    <img src="mvn-14-2.png" width="70%">
    <p>
        После того, как прошел весь цикл до test - увидели ещё один плагин <b>maven-jar-plugin:2.4:jar</b> (на скрине
        его нет, но на самом деле он есть), который сформировал .jar файл и засунул в директорию
        <code>target\first-maven-1.0-SNAPSHOT.jar</code>. Следовательно, он туда упаковал все наши исходники и назвал
        по имени проекта, версии и packaging-type:
    </p>
    <img src="mvn-14-3.png" width="30%">
    <p>
        <b>Важный нюанс:</b> .jar которая сформировалась не включает в себя зависимости. Т.е. все зависимости, которые
        указали в POM - они не будут внутри jar. Следовательно, она т.н. не executable. Не сможем использовать для
        запуска приложения. Поэтому есть два варианта:
    </p>
    <ol>
        <li>
            Создать executable-jar - для этого придется познакомиться с определенным плагином.
        </li>
        <li>
            Создать структуру приложения наподобие maven или tomcat, где у нас есть собственно проект .jar и отдельно
            директория lib, где собраны зависимости и в CLASSPATH при вызове нашей .jar указана директория, где эти
            lib лежат для того чтобы могли работать с нашим приложением.
        </li>
    </ol>
    <p>
        <b>По умолчанию</b> все наши POMки используют этот (.jar) packaging-type если мы его не переопределим. Т.е.
        есть специальный тег <code>&lt;packaging>&lt;/packaging></code>, который по умолчанию jar. Он может быть ещё
        war, pom, bundle, maven-plugin (если хотим создать мавен плагин) и т.д..
    </p>
    <pre>
        &lt;groupId>com.kainv&lt;/groupId>
        &lt;artifactId>first-maven&lt;/artifactId>
        &lt;version>1.0-SNAPSHOT&lt;/version>
        &lt;packaging>jar&lt;/packaging>
    </pre>
    <p>
        <b>Это очень важный нюанс</b>, потому что packaging-type полностью меняет все наши goal'ы, которые
        привязываются к нашим фазам. Какие goal'ы вызываются на какой конкретно фазе - все зависит от packaging-type.
    </p>
    <p>Обратимся к документации</p>
    <img src="mvn-14-4.png" width="70%">
    <p>
        Именно дефолтный lifecycle и следующие packaging-type (ejb, ejb3, jar, par, rar, war) запускается всё тоже
        самое,
        что уже прошли.
    </p>
    <p>
        Но если поменяем packaging-type к примеру на ear, то goal'ы привязанные к фазам уже отличаются. Уже видим, что
        нет фазы compile, поскольку никакие goal'ы к ней не привязаны, но за то привязаны другие к фазам.
    </p>
    <img src="mvn-14-5.png" width="70%">
    <p>
        Здесь видим <code>plugin:descriptor</code>, который формирует какой-то файл-дескриптор плагина и добавляет его в
        папку resources в наших исходниках. На фазе package дополнительно вызывает плагин для, который собирает
        метаданные для нашего плагина.
    </p>
    <img src="mvn-14-6.png" width="70%">
    <img src="mvn-14-7.png" width="70%">
</article>
<article>
    <h1>Maven. 13. Default Lifecycle. Test phase. Surefire plugin</h1>
    <img src="mvn-11-1.png" width="70%">
    <p>
        На этапе <b>test</b> есть три фазы, к которым по умолчанию привязаны goal:
    </p>
    <ul>
        <li>
            <b>process-test-resources</b> - аналогия с process-resources, но для тестовых файлов.
        </li>
        <li>
            <b>test-compile</b> - для того чтобы скомпилировать все наши классы из src/main/test.
        </li>
        <li>
            <b>test</b> - для запусков наших тестов.
        </li>
    </ul>
    <p>
        Все остальные фазы не содержат никаких goal по умолчанию, но можем в любое время подключить любой goal любого
        плагина.
    </p>
    <ul>
        <li>
            <b>process-classes</b> - нужен для того, чтобы выполнить какую-ту обработку классов, которые скомпилировали
            на предыдущей фазе.
        </li>
        <li>
            <b>generate-test-sources</b> - хотим сгенерировать какие-то дополнительные исходники для тестов.
        </li>
        <li>
            <b>process-test-sources</b> - обработать их.
        </li>
        <li>
            <b>generate-test-resources</b> - сгенерировать тестовые ресурсы (статику) и подложить в директорию
            resources.
        </li>
        <li>
            <b>process-test-resources</b> - берёт из этой директории и кладёт в директорию target. Дополнительно
            можно отфильтровать, указать переменные и прочее.
        </li>
    </ul>
    <p>
        Введя <code>mvn test</code> в директории target получим папку test-classes в которой будут лежать
        скомпилированные
        классы из src/test.
    </p>
    <img src="mvn-13-2.png" width="30%">
</article>
<article>
    <h1>Maven. 12. Default Lifecycle. Validate and Compile phases</h1>
    <img src="mvn-11-1.png" alt="" width="70%">
    <h2>validate</h2>
    <p>
        validate по сути только валидирует проект на корректность. На то, все ли правильно заполнено в POM'ках и по сути
        не вызывает ничего. Нет никаких goal связанных с этой фазой.
    </p>
    <h3>initialize</h3>
    <p>
        На фазе initialize по дефолту ничего не происходит, но она насчитана на то, что мы можем привязать свой
        плагин и установить какие-то дополнительные пропертисы либо создать директории. Т.е. что-то дополнительное для
        инициализации проекта.
    </p>
    <h3>generate-sources</h3>
    <p>
        generate-sources - на этой фазе также можем привязать какой-то плагин потому что по дефолту нет ничего
        связанное с этой фазой и она рассчитана на то, что мы хотим сгенерировать какие-то исходники. Обычно есть
        какие-то генераторы типа <i>"Querydsl"</i> которые создают дополнительно java-классы на этой фазе. Эта фаза
        будет использоваться далее в Hibernate.
    </p>
    <h3>process-sources</h3>
    <p>
        Обрабатываем все наши исходники. Можем фильтровать их и поставить переменные в них.
    </p>
    <h3>generate-resources</h3>
    <p>
        Аналог generate-sources, но генерирует ресурсные файлы из директории .m2/resources.
    </p>
    <h3>process-resources</h3>
    <p>
        Фаза, на которой привязана первая goal из плагина resources. Обрабатывает ресурсные файлы. Т.е. берёт директорию
        target и кладёт туда все ресурсы из папки main resources. Дополнительно может отфильтровать их и поставить
        значения.
        Так же как и в process-sources, только для статических файлов из директории resources.
    </p>
    <h2>compile</h2>
    <p>
        Для того чтобы вызвать compile, нам необходимо пройти все предыдущие фазы до compile. Потому что так работает
        maven. Если хотим в каком-то из нижнего цикле вызвать какую-либо фазу, то вызываются все предыдущие фазы в том
        же самом жизненном цикле.
    </p>
    <p>
        Привязан compiler плагин и его goal compile. Он всего лишь компилирует наши исходники из main/src директории
        и кладёт их в директорию target/classes.
    </p>
    <p>
        Выполним <code>mvn compile</code> увидим:
    </p>
    <img src="mvn-12-2.png" width="20%">
    <h2>Мы так же можем переопределять плагины и перенастраивать их</h2>
    <pre>
        &lt;build>
            &lt;plugins>
                &lt;plugin>
                    &lt;groupId>org.apache.maven.plugins&lt;/groupId>
                    &lt;artifactId>maven-compiler-plugin&lt;/artifactId>
                    &lt;version>3.8.0&lt;/version>
                    &lt;!-- Конфигурируем плагин-->
                    &lt;configuration>
                        &lt;!-- Устанавливаем версию исходников -->
                        &lt;source>15&lt;/source>
                        &lt;!-- И компилируем в 19 версию java. По умолчанию 1.7-->
                        &lt;!-- Теперь после билда мавена можно в плагин классах можно использовать фичи 19й java-->
                        &lt;target>19&lt;/target>
                    &lt;/configuration>
                &lt;/plugin>
            &lt;/plugins>
        &lt;/build>
    </pre>
</article>
<article>
    <h1>Maven. 11. Project Lifecycles. Clean Lifecycle</h1>
    <p>
        Жизненный цикл проекта - это основной аспект в maven, который позволяет полностью управлять жизнедеятельностью
        проекта начиная от написания заканчивая деплоем в продакшн.
    </p>
    <p>
        <b>Project lifecycle</b> (жизненный цикл проекта) - это набор фаз (<b>phase</b>), которые следуют по очереди
        друг за другом.
    </p>
    <p>
        <b>Phase</b> (фаза) - один из этапом project lifecycle, который состоит из целей (<b>goal</b>).
    </p>
    <img src="mvn-11-1.png" width="70%">
    <p>
        Если брать пример из жизни, то project lifecycle - это сутки, а phase - всего лишь обозначение какой-то части
        в этих сутках: утро, день, вечер, ночь. Если зайдём в код, то phase - это всего лишь enum с перечнем всех
        возможных фаз, которые есть в maven.
    </p>
    <p>
        В maven существует три жизненных цикла: <b style="color: green">Clean</b>,
        <b style="color: lightcoral;">Default (Build)</b>, <b style="color: dodgerblue;">Site</b>. У каждого из этих
        lifecycle есть набор фаз, которые следуют друг за другом по очереди (см. картинку, основные фазы подчеркнуты
        красным цветом).
    </p>
    <p>
        <b style="color: lightcoral;">Default (Build)</b> является главным из всех жизненных циклов потому что он
        содержит гораздо больше фаз. В нём основные фазы это:
    </p>
    <ul>
        <li>
            <b>validate</b> - валидирует все POM в проекте.
        </li>
        <li>
            <b>compile</b> - занимается компиляцией нашего проекта, именно sources, которые лежат в main.
        </li>
        <li>
            <b>test</b> - запускает тесты, юнит-тесты для проверки исходных кодов.
        </li>
        <li>
            <b>package</b> - занимается упаковкой проектов в соответствующий artifact.
        </li>
        <li>
            <b>verify</b> - запуск уже интеграционных тестов на основании того, что упаковали. Т.е. у наших jar есть
            ещё интеграционные тесты, для того чтобы проверить собранный artifact.
        </li>
        <li>
            <b>install</b> - фаза, которая занимается копированием artifact'ов с фазы package в локальный .m2
            репозиторий.
        </li>
        <li>
            <b>deploy</b> - занимается тем, что берёт из директории .m2/repository и пушит их в удалённый.
        </li>
    </ul>
    <p>
        <b>Главный момент</b>: с каждой фазой связана цель либо несколько целей, но так же может быть и не связано
        ни одной.
    </p>
    <p>
        В случае нашего жизненного цикла <b style="color: lightcoral;">Default (Build)</b> набор этих целей
        напрямую зависит от того, во что мы собираем наш проект. Т.е от настройки package. Нет прямого соответствия
        между фазами и целями потому что перечень целей может быть отличным от того, во что собираем наш проект.
    </p>
    <p>
        Фаза <b>site</b> в lifecycle <b style="color: dodgerblue;">Site</b> занимается генерацией различных отчётов,
        репортов. Например, генерирует документацию по исходным файлам. Либо сгенерируется отчёт по тестам, которые
        прошли и т.д..
    </p>
    <p>
        В случае lifecycle <b style="color: green">Clean</b> - это самый простой жизненный цикл проекта, где мы просто
        чистим директорию target.
    </p>
    <p>
        Есть два варианта вызова фазы: <code>mvn &lt;plugin>:&lt;goal></code> & <code>mvn &lt;название фазы></code>.
    </p>
</article>
<article>
    <h1>Maven. 10. Transitive dependencies</h1>
    <p>
        Транзитивная зависимость - это когда одна библиотека зависит от другой. Если подключаем зависимость, которая в
        свою очередь зависит от другой, то та другая так же неявно подтягивается. Как в примере из Maven 8.
    </p>
    <h2>
        Как maven определяет транзитивные зависимости и подкачивает их вместе с основной зависимостью?
    </h2>
    <img src="mvn-8-2.png" width="70%">
    <p>
        Как видели в maven 8, в подтянутой зависимости есть разного расширения файлы. Для определения транзитивной
        зависимости maven используем файл с расширением <b>.pom</b>, поэтому он её и выкачивает.
    </p>
    <p>
        <b>Важно помнить</b>, что maven выгружает вместе с основной <b>.jar</b> ещё и <b>.pom</b>.
    </p>
    <h2>Нюансы с транзитивной зависимостью</h2>
    <p>Например, подключим пару зависимостей от Spring:</p>
    <pre>
        &lt;dependency&gt;
            &lt;groupId&gt;.springframework&lt;/groupId&gt;
            &lt;artifactId>spring-webmvc&lt;/artifactId&gt;
            &lt;version>5.0.5.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency>
            &lt;groupId>org.springframework&lt;/groupId>
            &lt;artifactId>spring-aop&lt;/artifactId>
            &lt;version>5.1.7.RELEASE&lt;/version>
        &lt;/dependency>
    </pre>
    <p>
        Дело в том, что зависимости Spring тянут дополнительно ещё много транзитивных зависимостей и проблема начинается
        тогда, когда транзитивные зависимости не совпадают по версии с другими транзитивными зависимостями: точно такими
        же по groupId & artifactId, но версия другая. Это чревато большими последствиями, когда есть проблема
        несовместимости версий.
    </p>
    <p>
        Зайдём в терминал и выполним команду, но с дополнительным флагом <code>mvn dependency:tree -Dverbose</code>.
        В этом случае получим более подробную картину происходящего:
    </p>
    <img src="mvn-10-2.png" width="50%">
    <p>
        Видим две зависимости спринга и в некоторых из них зависимости помечены как <b>omitted from ....</b>. Т.е.
        таким образом maven решает проблемы транзитивной зависимости, а точнее конфликты этих версий. Другими словами
        говоря, он просто опускает некоторые зависимости и передаёт зависимости из другой .jar. Например, в случае
        нашего <b>spring-aop</b> мы видим, что он опустил .jar'ку <b>spring-beans</b> версии 5.1.7 и взял 5.0.5 потому
        что у нас она есть в другой зависимости - <b>spring-webmvc</b>. Все потому что если посмотреть на зависимости,
        то <b>webmvc</b> идёт до того, как показали AOP.
    </p>
    <p>
        Следовательно, <b>первый нюанс в зависимостях maven</b><i> - это то, что транзитивные зависимости перекрывают
        другие транзитивные зависимости если главная зависимость идёт выше в нашем конфигурационном файле.</i>
    </p>
    <p>
        Поэтому, в данном случае <b>spring-webmvc</b> выигрывает, чем <b>spring-aop</b>. Поэтому spring-aop взял
        более старую версию. Это на самом деле плохо, потому что в таком случае скорее всего будет ошибка во время
        компиляции или выполнения. Это не очень хороший вариант решения, который придумал maven. В Gradle всегда берётся
        более старшая версия какой бы порядок не соблюдали.
    </p>
    <p>
        Второй вариант решения данной проблемы - это использование специального тега
        <code>&lt;exclusions>&lt;/exclusions></code>. В нём можем перечислить несколько зависимостей, которые хотим
        исключить из нашей основной зависимости. Т.е. какие транзитивные зависимости не должны попасть к нам вместе
        со <b>spring-webmvc</b>.
    </p>
    <p>
        Отключим в <b>spring-webmvc</b> зависимость <b>spring-beans</b> для того чтобы взяли <b>spring-beans</b> из
        <b>spring-aop</b>:
    </p>
    <pre>
        &lt;dependency>
            &lt;groupId>.springframework&lt;/groupId>
            &lt;artifactId>spring-webmvc&lt;/artifactId>
            &lt;version>5.0.5.RELEASE&lt;/version>
            &lt;exclusions>
                &lt;exclusion>
                    &lt;groupId>org.springframework&lt;/groupId>
                    &lt;artifactId>spring-beans&lt;/artifactId>
                &lt;/exclusion>
            &lt;/exclusions>
        &lt;/dependency>
    </pre>
    <p>И сгенерируем дерево в консоли:</p>
    <img src="mvn-10-3.png" width="50%">
    <p>
        В данном случае <b>spring-beans</b> уже не опущен, приложение берёт именно версию более старшую потому что
        исключили более старую из <b>spring=webmvc</b>. Таким образом, при помощи
        <code>&lt;exclusions>&lt;/exclusions></code>
        можно исключать транзитивные зависимости когда происходит конфликт.
    </p>
    <h2>Тэг <code>&lt;optional>&lt;/optional></code></h2>
    <p>
        По умолчанию, в нём есть два значения: <code>true</code> & <code>false</code>. По умолчанию <code>false</code>,
    </p>
    <p>
        Добавим ещё одну зависимость:
    </p>
    <pre>
            &lt;dependency>
                &lt;groupId>mysql&lt;/groupId>
                &lt;artifactId>mysql-connector-java&lt;/artifactId>
                &lt;version>8.0.23&lt;/version>
                &lt;scope>runtime&lt;/scope>
                &lt;optional>true&lt;/optional>
            &lt;/dependency>
    </pre>
    <p>
        Получается, что другой проект, который будет подключать в качестве зависимости наш <b>first-maven</b> -
        транзитивно должен был бы подтянуть <b>postgres</b> & <b>mysql-connector</b>, но он этого делать не будет потому
        что <code>&lt;optional>true&lt;/optional></code> установлен в <code>true</code>, но он должен выбрать одну из
        этих опционных зависимостей. Т.е., мы зависим либо от postgres, либо от mysql. И тот, кто подключает наш проект
        в качестве зависимостей должен сам для себя выбрать, какая из этих зависимостей ему нужна в качестве
        транзитивных явно прописав в своем теге <code>&lt;dependencies>&lt;/dependencies></code>. На практике лучше
        <code>&lt;optional>true&lt;/optional></code> не использовать. Просто закомментируем в POM'е.
    </p>
</article>
<article>
    <h1>Maven. 9. Dependency scope</h1>
    <p>Кроме таких атрибутов как</p>
    <pre>
        &lt;groupId&gt;&lt;/groupId&gt;
        &lt;artifactId&gt;&lt;/artifactId&gt;
        &lt;version&gt;&lt;/version&gt;
    </pre>
    <p>
        Существует ещё атрибут <code>&lt;scope&gt;&lt;/scope&gt;</code>. Из есть пять разных вариантов:
    </p>
    <ul>
        <li>
            <code>&lt;scope&gt;compile&lt;/scope&gt;</code> - идёт по умолчанию в наши зависимости, даже если не
            указываем явно. Он говорит о том, что данная зависимость нужна для компиляции проекта. Т.е. без этой
            зависимости никак не сможем скомпилировать проект. Другими словами говоря, если соберём приложение в .jar
            файл, то этот файл будет полностью зависеть от зависимости другой, которая помечена как <b>compile</b>.
            Без неё он работать не будет.
        </li>
        <li>
            <code>&lt;scope&gt;provided&lt;/scope&gt;</code> (jakarta.servlet-api следует использовать не <b>compile</b>,
            а <b>provided</b>) - это означает, что эта зависимость будет предоставлена кем-то другим. В данном случае
            эта зависимость лежит в директории lib нашего Tomcat, а т.к. мы будем использовать веб-приложение, потому
            что
            эта зависимость нужна только для веб-приложений, то, следовательно, она будет в Tomcat'e и не нужно будет
            добавлять в CLASSPATH проекта. Поэтому это <b>provided</b>. Естественно, она добавляется для того чтобы
            могли
            обращаться к нашим классам из FirstServlet. В противном случае без <b>provided</b> зависимости просто не
            будет виден HttpServlet.
        </li>
        <li>
            <code>&lt;scope&gt;runtime&lt;/scope&gt;</code> прекрасный пример - драйвер в JDBC. (Подключим драйвер для
            postgres в commit maven 9). Т.е., во время компиляции нам не нужен этот драйвер (зависимость) вообще, только
            во время выполнения (когда получили соединения). <b>Проще говоря</b>, используем когда во время компиляции
            не надо, а во время runtime нужно.
        </li>
        <li>
            <code>&lt;scope&gt;system&lt;/scope&gt;</code> - <b>не следует никогда использовать</b> - означает, что
            указываем зависимость, который лежит у нас на компьютере. Т.е., по сути указываем путь к .jar, который лежит
            на компьютере (путь указывается тэгом <code>&lt;systemPath&gt;</code>). Следовательно, её не рекомендуется
            использовать вообще.
        </li>
        <li>
            <code>&lt;scope&gt;test&lt;/scope&gt;</code> - этот скоуп говорит о том, что эта зависимость нужна только
            во время выполнения наших тестов. В нашу результирующую .jar она не должна попасть так же как и
            <b>provided</b>. Только отличие в том, что <b>provided</b> нужна для выполнения и жизнедеятельности проекта,
            но будет предоставлена каким-то другим приложением. В случае же с <b>test</b> - она нам в принципе не нужна.
            Только тогда, когда выполним тесты и проверим, что приложение работает успешно.
        </li>
    </ul>
    <p>
        Чтобы посмотреть все зависимости, которые наследуются от других pom или модулей, если специальный плагин. Для
        этого в терминале обращаемся к плагину. Посмотрим какие есть goal у этого плагина:
        <code>mvn dependency:help</code>. У него много goal, но нас будут интересовать два из них:
    </p>
    <ul>
        <li>
            <code>dependency:analyze</code> - анализирует зависимости
        </li>
        <li>
            <code>dependency:tree</code> - билдит всю иерархию зависимостей вместе с зависимостью нашей зависимости
            и т.д. Называют ещё транзитивной зависимостью.
        </li>
    </ul>
    <p>
        Поэтому можем набрать <code>mvn dependency:analyze</code> и увидим статистику по зависимостям и принимать
        решение:
        что можно убрать, что оставить.
    </p>
    <img src="mvn-9-1.png" width="50%">
    <p>
        В данном случае видим, что есть зависимость, которая никогда не используется: org.postgresql. Видим это в
        консоли, где строка отмечена <b>[<span style="color: orange">WARNING</span>]</b>. Таким образом, можем
        анализировать зависимости и определять, всё ли у нас хорошо с POM.
    </p>
    <p>Посмотрим ещё дерево зависимостей: <code>mvn dependency:tree</code></p>
    <img src="mvn-9-2.png" width="50%">
    <p>
        Видим, что есть проект, который собирается в .jar, где видим <b>groupId</b>, <b>artifactId</b>, <b>version</b>:
    </p>
    <pre>[INFO] com.kainv:first-maven:jar:1.0-SNAPSHOT</pre>
    <p>
        И он зависит от трёх других:
    </p>
    <pre>
[INFO] +- junit:junit:jar:4.13.1:test
<span style="color: lightgray">[INFO] |  \- org.hamcrest:hamcrest-core:jar:1.3:test</span>
[INFO] +- jakarta.servlet:jakarta.servlet-api:jar:5.0.0:provided
[INFO] \- org.postgresql:pgjdbc-osgi-test:jar:42.3.8:runtime
    </pre>
    <p>
        В свою очередь, junit зависит от
    </p>
    <pre>
        [INFO] |  \- org.hamcrest:hamcrest-core:jar:1.3:test
    </pre>
    <p>
        Такая зависимость называется транзитивной. Мы её получили неявно.
    </p>
</article>
<article>
    <h1>Maven. 8. Dependency management</h1>
    <p>
        Познакомимся с одним из основных тегов - <code>&lt;dependencies&gt;&lt;/dependencies&gt;</code>. Этот тег
        используется нами, а точнее maven проектами в том случае, когда нам необходимо привнести новую зависимость в
        проект. Т.е. по другому говоря, .jar файлы.
    </p>
    <p>
        В тэге <code>&lt;dependencies&gt;&lt;/dependencies&gt;</code> можем указывать только тег <code>&lt;dependency&gt;
        &lt;/dependency&gt;</code>. Таким образом можем подключать множество зависимостей и они будут в CLASSPATH нашего
        проекта. Для подключения зависимостей нужно подключать уникальный идентификатор, который состоит из трёх
        основных
        элементов:
    </p>
    <pre>
        &lt;groupId&gt;&lt;/groupId&gt;
        &lt;artifactId&gt;&lt;/artifactId&gt;
        &lt;version&gt;&lt;/version&gt;
    </pre>
    <p>
        Например, если хотим подключить зависимости сервлетов, то пишем:
    </p>
    <pre>
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;jakarta.servlet&lt;/groupId&gt;
                &lt;artifactId&gt;jakarta.servlet-api&lt;/artifactId&gt;
                &lt;version&gt;5.0.0&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    </pre>
    <p>
        Но когда мы их подключили, перейдя в класс и захотим написать сервлет, то в CLASSPATH не будет видна
        зависимость.
        Для этого мы должны "подтянуть" эту зависимость. <i>Подтянуть</i> - означает скачать зависимость в директорию
        локального репозитория под названием <b>.m2</b>, а именно <b>.m2/repository</b>. Этот репозиторий хранится
        локально и он является общим для всего локального компьютера и будет видна во всех проектах.
    </p>
    <p>
        Поэтому, переходим в эту директорию. Это дефолтная репозитория локального репозитория. В ней есть директория
        <b>/repository</b>. Именно <b>.m2/repository</b> используется maven'ом для скачивания сторонних зависимостей
        из удалённого репозитория. Перейдя в этот репозиторий можно посмотреть все зависимости, которые уже скачаны.
    </p>
    <p>
        Что у нас получается:
    </p>
    <img src="mvn-8-1.png" width="60%">
    <p>
        У нас есть проекты (first-maven в данном случае) и все они ищут зависимости локально на машине в директории
        пользователя <b>~/.m2/repository</b>. Если в этой директории не нашлось зависимости, то maven идёт в удаленный
        репозиторий, который прописан в <i>super pom</i>: <a href="https://repo.maven.apache.org/maven2">
        https://repo.maven.apache.org/maven2</a>. И оттуда, если нашлись зависимости, то скачиваются в локальный
        репозиторий и можем использовать в проекте. В следующий раз уже не пойдёт в удалённый репозиторий, если уже
        будет
        выкачано локально.
    </p>
    <p>
        В случае с нашим примером с jakarta: в .m2/repository должна лежать директория <b>jakarta</b>, в которой лежит
        директория <b>servlet</b>. Если туда зайдём, то увидим <b>jakarta.servlet-api</b>, а внутри неё будет директория
        <b>5.0.0</b>, потому-что версий может быть множество. И уже внутри этой директории будет лежать зависимость.
    </p>
    <img src="mvn-8-2.png" width="70%">
    <p>
        Перейдя в зависимость можно увидеть <b>-sources.jar</b> (отдельно jar с исходными кодами, по умолчанию maven
        всегда их подхватывает), дальше видим саму .jar с зависимостями скомпилированными и ещё .pom. Ещё есть .sha1, но
        оно сейчас не нужно, потому что используется для взаимодействия с удалёнными репозиториями. Теперь можем
        споконо использовать <b>.jar</b> в нашем проекте. Естественно, .m2/repository можно переписать, но она уже
        находится не в super pom, в настройках нашего maven: <b>${maven}/conf/settings.xml</b>. Именно в этом
        <b>settings.xml</b> можем поправить дефолтные репозитории, если захотим. <b>Но лучше этого не делать</b>.
    </p>
    <p>
        Мы увидили её в локальном репозитории, но почему-то у нас всё ещё сервлет не видит класс HttpServlet. Все потому
        что должны ещё заимпортить .jar в наш проект из нашего локального репозитория.
    </p>
    <img src="mvn-8-3.png" width="25%">
    <p>
        Более того, теперь мы видим все зависимости, которые нам подключил maven из локального репозитория. Таким
        образом, мы очень легко и просто можем подключать зависимости в наш проект.
    </p>
    <img src="mvn-8-4.png" width="25%">
</article>
<article>
    <h1>Maven. 7. Super POM - битый</h1>
    <p>
        <b>Super POM</b> - это по сути суперкласс, от которого наследуются другие классы. Т.е., super pom содержит XML
        атрибуты, которые билдятся по умолчанию даже если не указываем их в своем собственном pom. Через команду
        <code>mvn help:effective-pom</code>.
    </p>
    <p>
        Мы можем задавать только конкретные теги и атрибуты. Не можем придумать какие-то свои.
    </p>
    <p>
        В super POM есть по дефолту все директории которые нам необходимы.
    </p>
</article>
</body>
</html>